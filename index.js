// Generated by CoffeeScript 2.3.0
(function() {
  // We support logging using debug (console), socket.io (our own), or GELF over TLS.
  var Debug, EventEmitter, Now, __debug, default_host, dev_logger, events, logger, os, process_logger, ref, seem, util, w;

  Debug = require('debug');

  __debug = Debug('tangible');

  util = require('util');

  seem = require('seem');

  EventEmitter = require('events');

  w = new EventEmitter();

  events = ['dev', 'ops', 'csr'];

  os = require('os');

  default_host = (ref = process.env.CUDDLY_HOST) != null ? ref : os.hostname();

  dev_logger = process.env.NODE_ENV !== 'production';

  if (process.env.DEV_LOGGER === 'true') {
    dev_logger = true;
  }

  if (process.env.DEV_LOGGER === 'false') {
    dev_logger = false;
  }

  Now = function() {
    return new Date().toJSON();
  };

  module.exports = logger = function(default_name, suffix) {
    var debug, foot, hand, heal, make_debug, session;
    session = this.session;
    // * session.dev_logger (boolean) whether to trace for this session
    make_debug = (e) => {
      var _debug, full_name, local_name;
      local_name = default_name;
      full_name = local_name != null ? local_name : '(no name)';
      if (suffix != null) {
        full_name += `:${suffix}`;
      }
      _debug = Debug(`${full_name}:${e}`);
      // This is the actual logging function.
      return (text, ...args) => {
        var arg, data, error, extra, host, logging, message, now, ref1, ref2, session_logger;
        [arg, ...extra] = args;
        if (this.session != null) {
          session = this.session;
        }
        now = Now();
        host = (ref1 = session != null ? session.logger_host : void 0) != null ? ref1 : default_host;
        session_logger = session != null ? session.dev_logger : void 0;
        // If a default name is set, we should use it.
        // Otherwise, we try to guess the current name based on the middleware's name. (This does not work well in async functions.)
        if (default_name == null) {
          if (local_name !== this.__middleware_name) {
            local_name = this.__middleware_name;
            full_name = local_name != null ? local_name : '(no name)';
            if (suffix != null) {
              full_name += `:${suffix}`;
            }
            _debug = Debug(`${full_name}:${e}`);
          }
        }
        logging = dev_logger || session_logger;
        data = {
          stamp: now,
          now: Date.now(),
          host: host,
          session: (ref2 = session != null ? session._id : void 0) != null ? ref2 : null,
          reference: session != null ? session.reference : void 0,
          application: default_name != null ? default_name : local_name,
          method: suffix,
          event: e,
          msg: text,
          logging: logging
        };
        // If the parameters are serializable, store them as-is.
        // Otherwise store them as a string.
        if (arg != null) {
          try {
            JSON.stringify(arg);
            data.data = arg;
          } catch (error1) {
            error = error1;
            data.data_error = true;
            data.data = util.inspect(arg);
          }
        }
        if (extra.length > 0) {
          try {
            JSON.stringify(extra);
            data.extra = extra;
          } catch (error1) {
            error = error1;
            data.extra_error = true;
            data.extra = util.inspect(extra);
          }
        }
        w.emit(e, data);
        // Debug
        if (logging) {
          message = `${now} ${host} ${text}`;
          _debug(message, ...args);
        }
      };
    };
    // Register for `trace` as `@debug`,
    debug = make_debug('trace');
    // and inject `@debug.dev`, `@debug.ops`, `@debug.csr`.
    events.forEach((e) => {
      return debug[e] = make_debug(e);
    });
    // and inject `@debug.catch`
    debug.inspect = util.inspect;
    debug.error = function(msg, error) {
      var ref1;
      return debug.dev(`${msg}: ${(ref1 = error.stack) != null ? ref1 : debug.inspect(error)}`);
    };
    debug.catch = function(msg) {
      return function(error) {
        return debug.error(msg, error);
      };
    };
    // `heal` is used to catch-and-log promises rejections (async).
    heal = function(p) {
      return p.catch(debug.catch('(caught/ignored)'));
    };
    // `hand` is used to wrap event handlers generators (use it instead of `seem` to log errors).
    hand = function(f) {
      return foot(seem(f));
    };
    // `foot` is used to wrap async event handlers.
    foot = function(f) {
      return function(...args) {
        return heal(f(...args));
      };
    };
    // Include itself so that we can do `{debug,heal,hand} = (require 'tangible') 'name'`.
    debug.heal = heal;
    debug.hand = hand;
    debug.foot = foot;
    debug.debug = debug;
    debug.events = w;
    return debug;
  };

  process_logger = logger('process');

  process.on('uncaughtException', function(error) {
    process_logger.error('uncaughtException', error);
    throw error;
  });

  process.on('unhandledRejection', function(reason, p) {
    return process_logger.error(`unhandledRejection on ${util.inspect(p)}`, reason);
  });

  // throw reason
  logger.enable = Debug.enable;

  logger.set_dev_logger = function(value) {
    return dev_logger = value;
  };

  logger.default_host = default_host;

  logger.use = function(plugin) {
    plugin(w, logger);
    return logger;
  };

}).call(this);
