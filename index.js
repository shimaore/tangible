// Generated by CoffeeScript 2.3.2
(function() {
  var Debug, EventEmitter2, debuglog, events, host, inspect, logger, os, process_logger, ref, w;

  Debug = require('debug');

  ({inspect, debuglog} = require('util'));

  ({EventEmitter2} = require('eventemitter2'));

  w = new EventEmitter2({
    wildcard: true,
    delimiter: ':',
    verboseMemoryLeak: true
  });

  events = ['dev', 'ops', 'csr'];

  os = require('os');

  host = (ref = process.env.TANGIBLE_HOST) != null ? ref : os.hostname();

  module.exports = logger = function(name) {
    var debug, foot, heal, make_debug;
    make_debug = function(e) {
      var _debug, _debuglog, full_name;
      full_name = `${name}:${e}`;
      _debug = Debug(full_name);
      _debuglog = debuglog(full_name);
      // This is the actual logging function.
      return function(text, ...args) {
        var data, error, now;
        _debug(text, ...args);
        _debuglog(text, ...args);
        if (!w.listenerCount(full_name)) {
          return;
        }
        now = Date.now();
        data = {
          stamp: new Date(now).toJSON(),
          now: now,
          host: host,
          application: name,
          event: e,
          msg: text
        };
        try {
          // If the parameters are serializable, store them as-is.
          // Otherwise store them as a string.
          JSON.stringify(args);
          data.data = args;
        } catch (error1) {
          error = error1;
          data.data_error = true;
          data.data = logger.inspect(args);
        }
        w.emit(full_name, data);
      };
    };
    // Register for `trace` as `@debug`,
    debug = make_debug('trace');
    // and inject `@debug.dev`, `@debug.ops`, `@debug.csr`.
    events.forEach((e) => {
      return debug[e] = make_debug(e);
    });
    // and inject `@debug.catch`
    debug.error = function(msg, error) {
      var ref1;
      return debug.dev(`${msg}: ${(ref1 = error.stack) != null ? ref1 : logger.inspect(error)}`);
    };
    debug.catch = function(msg) {
      return function(error) {
        return debug.error(msg, error);
      };
    };
    // `heal` is used to catch-and-log promises rejections (async).
    heal = function(t, p = null) {
      if (p == null) {
        return t.catch(debug.catch('(caught/ignored)'));
      } else {
        return p.catch(debug.catch(t));
      }
    };
    // `foot` is used to wrap async event handlers.
    foot = function(t, f = null) {
      if (f == null) {
        return function(...args) {
          return heal(t(...args));
        };
      } else {
        return function(...args) {
          return heal(t, f(...args));
        };
      }
    };
    // Include itself so that we can do `{debug,heal,hand} = (require 'tangible') 'name'`.
    debug.heal = heal;
    debug.foot = foot;
    debug.debug = debug;
    return debug;
  };

  process_logger = logger('process');

  process.on('uncaughtException', function(error) {
    process_logger.error('uncaughtException', error);
    throw error;
  });

  process.on('unhandledRejection', function(reason, p) {
    return process_logger.error(`unhandledRejection on ${logger.inspect(p)}`, reason);
  });

  // throw reason
  logger.inspect = inspect;

  logger.events = w;

  logger.use = function(plugin) {
    plugin(logger);
    return logger;
  };

}).call(this);
